---
title: Les hooks de React
description: DÃ©couvre les hooks de React, une fonctionnalitÃ© qui te permet de gÃ©rer le state et le cycle de vie de tes composants fonctionnels.
tags: [Frontend, React, JavaScript, TypeScript, BibliothÃ¨que, Interface utilisateur (UI)]
---

import Callout from "@/components/Callout";
import tabs from "./tabs";

Ã‡a y est, on rentre dans le vif du sujet avec les **hooks** de React !

On en a dÃ©jÃ  parlÃ© un peu dans l'article prÃ©cÃ©dent _(notamment avec le hook `useState` pour dÃ©clarer un state)_, mais on va maintenant les aborder en dÃ©tail.

## ğŸ£ Qu'est-ce qu'un hook ?

Tu te souviens du charabia dans l'article prÃ©cÃ©dent ?

> Un **hook** en React est une fonction qui permet d'exploiter les fonctionnalitÃ©s de React dans un composant fonctionnel _(fonction)_.

Essayons de comprendre cette phrase un peu plus en dÃ©tail en prenant l'origine des composants React.

Historiquement, on utilisait des **classes** pour dÃ©clarer des composants React plutÃ´t que des **fonctions**.  
C'Ã©tait pas mal, mais Ã§a devenait vite compliquÃ© Ã  gÃ©rer, notamment pour partager de la logique entre plusieurs composants _(comme le state par exemple)_.

Pour te donner un aperÃ§u, voici Ã  quoi ressemblait un composant de classe avec les trois Ã©tapes du cycle de vie :

<tabs.reactClassComponent />

Comme dirait l'un de mes chers confrÃ¨res jury :

> C'est pas tÃ©ros ğŸ˜•

Mais si tu as bien fait attention, tu as pu remarquer trois mÃ©thodes _(on ne prend pas le constructor en compte)_ qui sont appelÃ©es Ã  des moments prÃ©cis du cycle de vie du composant :

- `componentDidMount` : appelÃ©e aprÃ¨s le premier rendu du composant
- `componentDidUpdate` : appelÃ©e aprÃ¨s chaque mise Ã  jour du composant
- `componentWillUnmount` : appelÃ©e avant la suppression du composant

Seulement, comment on peut faire pour gÃ©rer ces Ã©tapes avec des composants fonctionnels ?  
Et bien c'est lÃ  qu'interviennent les **hooks** !

Avant de te montrer **comment** reproduire ces Ã©tapes avec des **hooks**, voici les **principaux hooks** de base que tu vas **trÃ¨s souvent** utiliser :

- `useState` : pour dÃ©clarer un **state**
- `useEffect` : pour gÃ©rer le **cycle de vie** d'un composant _(on en parle juste aprÃ¨s !)_

Il en existe d'autres bien entendu, mais ces deux-lÃ  sont les plus utilisÃ©s.  
On reviendra sur les autres hooks "basiques" un peu plus tard ğŸ˜‰

## useEffect, ou la machinerie du cycle de vie

Ce hook.. il est **tellement** puissant !  
Mais il est surtout trÃ¨s mal compris par les dÃ©butants _(et mÃªme parfois par les confirmÃ©s)_.

Il faut dire que Facebook n'a pas aidÃ© en le nommant `useEffect`, surtout que tu vas voir : c'est un couteau suisse ce machin ğŸ˜…

Pour faire court : `useEffect` permet de gÃ©rer le cycle de vie d'un composant fonctionnel _(comme `componentDidMount`, `componentDidUpdate` et `componentWillUnmount` pour les composants de classe)_.

Oui. Il fait tout. Tout seul.  
Tu comprends pourquoi je dis "couteau suisse" ? ğŸ˜

Alors sur le papier c'est top, mais maintenant je te laisse t'amuser Ã  comprendre comment Ã§a fonctionne ğŸ˜‡

<tabs.reactUseEffectSyntaxes />

Pas cool, hein ? ğŸ˜‚  
Et bien dans ces exemples, on a trois maniÃ¨res d'Ã©crire un useEffect :

1. Le hook est exÃ©cutÃ© une seule fois, aprÃ¨s le premier rendu du composant
2. Le hook est exÃ©cutÃ© Ã  chaque mise Ã  jour du composant
3. Le hook est exÃ©cutÃ© Ã  chaque mise Ã  jour du composant, mais seulement si la propriÃ©tÃ© `uneProp` de `props` a changÃ©

<Callout type="note" title="`useEffect` et les mises Ã  jour du composant">
  Alors quand je dis "le hook est exÃ©cutÃ© Ã  chaque mise Ã  jour du composant", il faut Ã©galement prendre en compte qu'il est Ã©galement exÃ©cutÃ© aprÃ¨s le premier rendu du composant.
</Callout>

Mais alors, comment on fait pour gÃ©rer ces Ã©tapes avec des composants fonctionnels ?  
Si tu n'as pas vu la diffÃ©rence entre les trois Ã©critures, tu remarqueras que c'est le deuxiÃ¨me argument de useEffect qui fait la diffÃ©rence.

Le premier argument lui, est une fonction synchrone _(pas le droit de la rendre asynchrone !)_. On mettra dedans tout ce qu'on veut exÃ©cuter lors de l'appel du hook.

Le deuxiÃ¨me argument est un tableau de dÃ©pendances.  
Selon ce tableau, le hook sera exÃ©cutÃ© Ã  des moments diffÃ©rents du cycle de vie du composant.

### âš™ï¸ ComponentDidMount

<tabs.reactUseEffectMount />

Le tableau de dÃ©pendances est vide, on sous-entend que le hook ne dÃ©pend d'aucune variable et sera exÃ©cutÃ© une seule fois.  
On peut donc dire que c'est l'Ã©quivalent de `componentDidMount` pour les composants de classe.

### ğŸ”§ ComponentDidUpdate

<tabs.reactUseEffectUpdate />

Ici, le tableau de dÃ©pendances est absent _(et tout va bien, il est optionnel !)_.  
Le hook sera exÃ©cutÃ© Ã  chaque mise Ã  jour du composant, ainsi que lors du premier rendu.

<tabs.reactUseEffectUpdateDependency />

Dans ce cas, le tableau de dÃ©pendances contient la propriÃ©tÃ© `uneProp` de `props`.
Le hook sera exÃ©cutÃ© Ã  chaque mise Ã  jour du composant _(ainsi qu'au montage)_, mais seulement si la propriÃ©tÃ© `uneProp` a changÃ©.

### ğŸ—‘ï¸ ComponentWillUnmount

Et lÃ , tu te dis : "Mais comment je fais pour gÃ©rer le dÃ©montage du composant ?".  
Hehehe, c'est lÃ  que Ã§a devient intÃ©ressant ğŸ˜

<tabs.reactUseEffectUnmount />

Tu as vu ce petit `return` ? Et bien, c'est notre Ã©quivalent de `componentWillUnmount` pour les composants de classe !

Dans cette fonction de retour, on mettra tout ce qu'on veut exÃ©cuter avant la suppression du composant.

### ğŸ“¦ Les dÃ©pendances

Tu as pu voir que le deuxiÃ¨me argument de `useEffect` est un tableau de dÃ©pendances.  
Ce tableau est trÃ¨s important, car il permet de gÃ©rer les mises Ã  jour du composant.

L'idÃ©e ici, c'est **d'optimiser** le rendu du composant en Ã©vitant de dÃ©clencher des mises Ã  jour inutiles.  
Pour Ã©viter que React se dise "Tiens, il y a eu un changement, je vais re-rendre le composant", on va lui dire "Non, non, il n'y a pas eu de changement sur la prop que je t'ai fourni, tu peux rester tranquille".

### ğŸ¤“ Exemple concret

Allez, mettons un peu ce qu'on voit de voir en pratique !

Voici un exemple de code qui utilise `useEffect` pour gÃ©rer le cycle de vie d'un composant :

<tabs.reactUseEffectExample />

### ğŸ”¢ On revient sur le cycle de vie !

Et... stoooop !  
On revient sur le cycle de vie d'un composant maintenant qu'on a vu `useEffect` en action !

Je vais te donner un exemple de code supplÃ©mentaire et tu vas devoir deviner l'ordre d'apparition des messages dans la console.

<tabs.reactUseEffectChallenge />

Voici les possibilitÃ©s :

<Callout type="question" title="Quel est l'ordre d'apparition des messages dans la console ?">
  - **A** - 4, 2, 1, 3
  - **B** - 2, 4, 1, 3
  - **C** - 1, 2, 3, 4
  - **D** - La rÃ©ponse D
</Callout>

## ğŸ§© Les autres hooks

On a vu les deux hooks les plus utilisÃ©s, mais il en existe d'autres qui peuvent Ãªtre trÃ¨s utiles dans certaines situations.

Par exemple, on a :

- `useContext` : pour accÃ©der Ã  un contexte
- `useReducer` : pour gÃ©rer un state complexe
- `useCallback` : pour Ã©viter les re-rendus inutiles
- `useMemo` : pour Ã©viter les calculs inutiles
- `useRef` : pour accÃ©der Ã  un Ã©lÃ©ment du DOM

Ne t'inquiÃ¨te pas, on va les voir plus tard car le hook `useEffect` est dÃ©jÃ  bien assez complexe Ã  comprendre pour le moment ğŸ˜…

## Conclusion

Et voilÃ , tu as maintenant toutes les clÃ©s en main pour gÃ©rer le cycle de vie de tes composants fonctionnels avec les hooks de React !

Vraiment, mÃªme si les autres hooks restent importants _(voire obligatoires dans certains contextes)_, tu as dÃ©jÃ  de quoi faire de bons composants avec seulement ces deux lÃ  ğŸ˜
