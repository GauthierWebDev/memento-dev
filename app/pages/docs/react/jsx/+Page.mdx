---
title: La syntaxe JSX de React
description: DÃ©couvrons la syntaxe JSX, un langage de balisage utilisÃ© par React pour dÃ©crire l'interface utilisateur.
tags: [Frontend, React, JavaScript, TypeScript, BibliothÃ¨que, Interface utilisateur (UI)]
---

import Callout from "@/components/Callout";
import tabs from "./tabs";

Avant de commencer Ã  parler des composants React, dÃ©couvrons tranquillement la syntaxe **JSX**.

Le **JSX** est un sucre syntaxique _(une syntaxe plus lisible et plus simple que le JavaScript pur)_ qui permet de dÃ©crire l'interface utilisateur _(UI)_ de notre application.

Le sigle en lui-mÃªme signifie **JavaScript XML**, dans le sens oÃ¹ l'on va retrouver une syntaxe proche du **XML** _(eXtensible Markup Language)_ qui est un langage de balisage _(comme le **HTML**)_.

## ğŸ” DiffÃ©rences entre HTML et JSX

Et oui, le **JSX** ressemble beaucoup au **HTML** et c'est normal !  
C'est l'objectif premier de **React** : rendre la crÃ©ation d'interfaces utilisateur _(UI)_ plus simple et plus intuitive.

Cependant il ne faut pas oublier que le **JSX** n'est pas du **HTML**, mais du **JavaScript**.

Pour faire plus simple, voici un Ã©lÃ©ment **HTML** et son Ã©quivalent avec React _(avec et sans JSX)_ :

<tabs.reactCreateElement />

Comme tu peux le constater, la diffÃ©rence entre le **JSX** et le **HTML** est minime.  
Il y a toutefois des diffÃ©rences, comme certains mots rÃ©servÃ©s _(comme `class` qui devient `className`)_ ou encore la maniÃ¨re de dÃ©clarer des Ã©vÃ©nements _(comme `onclick` qui devient `onClick`)_.

Par contre si on regarde la diffÃ©rence entre le **JSX** et le **JavaScript pur** _(en utilisant React quand mÃªme)_, on voit bien que le **JSX** est beaucoup plus lisible et plus simple Ã  Ã©crire.

LÃ  oÃ¹ c'est encore plus flagrant, c'est quand on commence Ã  imbriquer des Ã©lÃ©ments _(comme des composants React par exemple)_ !

<tabs.advancedReactCreateElement />

Et bien mÃªme si le code final est **identique**, le **JSX** apporte une lisibilitÃ© et une simplicitÃ© d'Ã©criture qui est trÃ¨s apprÃ©ciable. Pas mal non ? ğŸ˜„

Et donc oui ! En faisant du **JSX**, on fait en rÃ©alitÃ© du **JavaScript** et **pas du HTML** !


<Callout type="note" title="Importation de React et ses exports">
  Au sein de ses pages, tu verras **toujours** que j'importe le contenu de React en intÃ©gralitÃ© _(comme `import React from 'react';`)_.

  Dans la rÃ©alitÃ©, on va destructurer les exports de React pour n'importer que ce dont on a besoin.

  Cependant, pour te donner l'information d'oÃ¹ provient chaque Ã©lÃ©ment, je prÃ©fÃ¨re importer React en intÃ©gralitÃ© et que tu puisses visualiser les Ã©lÃ©ments de React utilisÃ©s avec leur provenance.
</Callout>

## ğŸ§© IntÃ©gration de JavaScript dans le JSX

Mais l'un des autres avantages du **JSX** est la possibilitÃ© d'ajouter du JavaScript directement dans le code !

Pour pouvoir ajouter du JavaScript dans le **JSX**, il suffit d'entourer le code JavaScript avec des accolades `{}`.
C'est un peu comme si on "ouvrait un portail" pour insÃ©rer du JavaScript dans notre code **JSX**.

### ğŸ“¦ Variables et fonctions

Par exemple, si tu veux afficher une variable dans ton JSX, tu peux le faire directement.  
Et si tu veux appeler une fonction, c'est tout aussi simple !

<tabs.reactVariablesAndFunctions />

### ğŸ“ Expressions

Tu peux Ã©galement ajouter des expressions _(comme des conditions ternaires par exemple)_.  
Mais tu peux aussi faire un **affichage conditionnel** pour sÃ©parer plus facilement les Ã©lÃ©ments d'interface.

<tabs.reactExpressions />

### ğŸ”„ï¸ Boucles

Maintenant imagine que tu souhaites crÃ©er une interface qui liste des Ã©lÃ©ments provenant d'un tableau.

<tabs.reactLoopsFruits />

Dans un premier temps, on va revoir trÃ¨s rapidement comment on peut parser un tableau en JavaScript :

<tabs.reactLoops />

En soit, toutes ces mÃ©thodes sont trÃ¨s bien et font ce qu'on leur demande sans souci.
Cependant, React ne va pas forcÃ©ment aimer Ã§a sauf pour `map`.

La raison est simple :  
React a besoin qu'on lui **retourne un Ã©lÃ©ment** _(ou un tableau d'Ã©lÃ©ments)_ pour pouvoir les afficher.

Alors avec des `console.log` on ne va pas aller loin, mais si au lieu de retourner un `console.log` on retournait un Ã©lÃ©ment **JSX** ? ğŸ¤”

<tabs.reactMapLoop />

[Voir l'exemple sur PlayCode](https://playcode.io/1940876)

Et lÃ  : **BAM** ! ğŸ’¥  
Tu viens de crÃ©er une liste de fruits en utilisant un tableau de fruits.

Mais par contre...

<Callout type="question" title="C'est quoi ce `key` qui vient d'apparaÃ®tre ?">
  La `key` est une propriÃ©tÃ© spÃ©ciale que React utilise pour identifier chaque Ã©lÃ©ment de maniÃ¨re unique.  
  Cela permet Ã  React de savoir quel Ã©lÃ©ment a Ã©tÃ© ajoutÃ©, modifiÃ© ou supprimÃ©.

  Il est **obligatoire** d'avoir une `key` **unique** pour chaque Ã©lÃ©ment d'une liste.  
  Si tu listes des Ã©lÃ©ments qui ont un identifiant unique _(comme l'`id` qu'on aura dans nos donnÃ©es stockÃ©es dans une base de donnÃ©es par exemple)_, tu peux utiliser cet identifiant comme `key`.
</Callout>

## ğŸ“¦ Les props

Les **props** _(ou propriÃ©tÃ©s)_ sont des arguments que l'on peut passer Ã  un composant React.  
Je ne vais pas trop rentrer dans les dÃ©tails ici, car on va les voir dans l'article d'aprÃ¨s !

Mais pour te donner un aperÃ§u, voici comment on peut passer des **props** Ã  un composant :

<tabs.reactProps />

Ici, on a un composant `Button` qui prend deux **props** : `onClick` et `children`.  
`onClick` est une fonction qui sera appelÃ©e lorsqu'on cliquera sur le bouton, et `children` est tout ce qui se trouve entre les balises ouvrante et fermante du composant.

## Conclusion

Alors, plutÃ´t cool le **JSX** non ? ğŸ˜

MÃªme si cette syntaxe rebute certains dÃ©veloppeurs _(souvent ils se la jouent puristes, mais chuuuuut ğŸ¤«)_, elle est toutefois trÃ¨s apprÃ©ciÃ©e pour sa simplicitÃ© et sa lisibilitÃ©.  
Question de goÃ»t aprÃ¨s tout !
