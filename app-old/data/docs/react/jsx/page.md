---
title: La syntaxe JSX de React
description: D√©couvrons la syntaxe JSX, un langage de balisage utilis√© par React pour d√©crire l'interface utilisateur.
tags: [Frontend, React, JavaScript, TypeScript, Biblioth√®que, Interface utilisateur (UI)]
---

Avant de commencer √† parler des composants React, d√©couvrons tranquillement la syntaxe **JSX**.

Le **JSX** est un sucre syntaxique _(une syntaxe plus lisible et plus simple que le JavaScript pur)_ qui permet de d√©crire l'interface utilisateur _(UI)_ de notre application.

Le sigle en lui-m√™me signifie **JavaScript XML**, dans le sens o√π l'on va retrouver une syntaxe proche du **XML** _(eXtensible Markup Language)_ qui est un langage de balisage _(comme le **HTML**)_.

## üîç Diff√©rences entre HTML et JSX

Et oui, le **JSX** ressemble beaucoup au **HTML** et c'est normal !  
C'est l'objectif premier de **React** : rendre la cr√©ation d'interfaces utilisateur _(UI)_ plus simple et plus intuitive.

Cependant il ne faut pas oublier que le **JSX** n'est pas du **HTML**, mais du **JavaScript**.

Pour faire plus simple, voici un √©l√©ment **HTML** et son √©quivalent avec React _(avec et sans JSX)_ :

{% tabs defaultSelectedTab="html" %}

{% tab value="html" label="HTML" %}

```html
<button class="button">Clique moi !</button>
```

{% /tab %}

{% tab value="react-no-jsx" label="React sans JSX" %}

```js
React.createElement("button", { className: "button" }, "Clique moi !");
```

{% /tab %}

{% tab value="jsx" label="React avec JSX" %}

```jsx
<button className="button">Clique moi !</button>
```

{% /tab %}

{% /tabs %}

Comme tu peux le constater, la diff√©rence entre le **JSX** et le **HTML** est minime.  
Il y a toutefois des diff√©rences, comme certains mots r√©serv√©s _(comme `class` qui devient `className`)_ ou encore la mani√®re de d√©clarer des √©v√©nements _(comme `onclick` qui devient `onClick`)_.

Par contre si on regarde la diff√©rence entre le **JSX** et le **JavaScript pur** _(en utilisant React quand m√™me)_, on voit bien que le **JSX** est beaucoup plus lisible et plus simple √† √©crire.

L√† o√π c'est encore plus flagrant, c'est quand on commence √† imbriquer des √©l√©ments _(comme des composants React par exemple)_ !

{% tabs defaultSelectedTab="react-no-jsx" %}

{% tab value="react-no-jsx" label="React sans JSX" %}

```js
React.createElement(
  React.Fragment,
  null,
  React.createElement("h2", null, "Formulaire de contact"),
  React.createElement(
    "form",
    { onSubmit: handleSubmit },
    React.createElement(
      "fieldset",
      null,
      React.createElement("label", { htmlFor: "lastname" }, "Nom"),
      React.createElement("input", { type: "text", name: "lastname", id: "lastname", required: true }),
    ),
    React.createElement(
      "fieldset",
      null,
      React.createElement("label", { htmlFor: "email" }, "Email"),
      React.createElement("input", { type: "email", name: "email", id: "email", required: true }),
    ),
    React.createElement(
      "fieldset",
      null,
      React.createElement("label", { htmlFor: "message" }, "Message"),
      React.createElement("textarea", { name: "message", id: "message", required: true }),
    ),
    React.createElement(
      "fieldset",
      null,
      React.createElement(
        "label",
        { htmlFor: "gdpr" },
        React.createElement("input", { type: "checkbox", name: "gdpr", id: "gdpr", required: true }),
        "J'accepte que mes donn√©es soient utilis√©es pour me recontacter",
      ),
    ),
    React.createElement("button", { type: "submit" }, "Envoyer"),
  ),
);
```

{% /tab %}

{% tab value="jsx" label="React avec JSX" %}

```jsx
<React.Fragment>
  <h2>Formulaire de contact</h2>
  <form onSubmit={handleSubmit}>
    <fieldset>
      <label htmlFor="lastname">Nom</label>
      <input type="text" name="lastname" id="lastname" required>
    </fieldset>

    <fieldset>
      <label for="email">Email</label>
      <input type="email" name="email" id="email" required>
    </fieldset>

    <fieldset>
      <label for="message">Message</label>
      <textarea name="message" id="message" required></textarea>
    </fieldset>

    <fieldset>
      <label for="gdpr">
        <input type="checkbox" name="gdpr" id="gdpr" required>
        J'accepte que mes donn√©es soient utilis√©es pour me recontacter
      </label>
    </fieldset>

    <button type="submit">Envoyer</button>
  </form>
</React.Fragment>
```

{% /tab %}

{% /tabs %}

Et bien m√™me si le code final est **identique**, le **JSX** apporte une lisibilit√© et une simplicit√© d'√©criture qui est tr√®s appr√©ciable. Pas mal non ? üòÑ

Et donc oui ! En faisant du **JSX**, on fait en r√©alit√© du **JavaScript** et **pas du HTML** !

{% callout type="note" title="Importation de React et ses exports" %}

Au sein de ses pages, tu verras **toujours** que j'importe le contenu de React en int√©gralit√© _(comme `import React from 'react';`)_.

Dans la r√©alit√©, on va destructurer les exports de React pour n'importer que ce dont on a besoin.

Cependant, pour te donner l'information d'o√π provient chaque √©l√©ment, je pr√©f√®re importer React en int√©gralit√© et que tu puisses visualiser les √©l√©ments de React utilis√©s avec leur provenance.

{% /callout %}

## üß© Int√©gration de JavaScript dans le JSX

Mais l'un des autres avantages du **JSX** est la possibilit√© d'ajouter du JavaScript directement dans le code !

Pour pouvoir ajouter du JavaScript dans le **JSX**, il suffit d'entourer le code JavaScript avec des accolades `{}`.
C'est un peu comme si on "ouvrait un portail" pour ins√©rer du JavaScript dans notre code **JSX**.

### üì¶ Variables et fonctions

Par exemple, si tu veux afficher une variable dans ton JSX, tu peux le faire directement :

```jsx
const name = "Jean Dupont";

return <h1>Bonjour {name} !</h1>;
```

Et si tu veux appeler une fonction, c'est tout aussi simple :

```jsx
const sayHello = () => "Bonjour !";

return <p>{sayHello()}</p>;
```

### üìù Expressions

Tu peux √©galement ajouter des expressions _(comme des conditions ternaires par exemple)_ :

```jsx
const age = 18;

return <p>{age >= 18 ? "Majeur" : "Mineur"}</p>;
```

Mais tu peux aussi faire un **affichage conditionnel** de mani√®re tr√®s simple :

```jsx
const isLogged = false;

return (
  <div>
    {isLogged && <p>Bienvenue sur notre site !</p>}
    {!isLogged && <p>Connectez-vous pour acc√©der √† notre site</p>}
  </div>
);
```

### üîÑÔ∏è Boucles

Maintenant imagine que tu souhaites cr√©er une interface qui liste des √©l√©ments provenant d'un tableau.

```jsx
const fruits = ["pomme", "banane", "fraise"];
```

Dans un premier temps, on va revoir tr√®s rapidement comment on peut parser un tableau en JavaScript :

- `for` :

  ```js
  for (let i = 0; i < fruits.length; i++) {
    console.log(fruits[i]);
  }
  ```

- `forEach` :

  ```js
  fruits.forEach((fruit) => {
    console.log(fruit);
  });
  ```

- `map` :
  ```js
  fruits.map((fruit) => {
    console.log(fruit);
  });
  ```

En soit, toutes ces m√©thodes sont tr√®s bien et font ce qu'on leur demande sans souci.
Cependant, React ne va pas forc√©ment aimer √ßa sauf pour `map`.

La raison est simple :  
React a besoin qu'on lui **retourne un √©l√©ment** _(ou un tableau d'√©l√©ments)_ pour pouvoir les afficher.

Alors avec des `console.log` on ne va pas aller loin, mais si au lieu de retourner un `console.log` on retournait un √©l√©ment **JSX** ? ü§î

```jsx
const fruits = ["pomme", "banane", "fraise"];

return (
  <ul>
    {fruits.map((fruit) => (
      <li key={fruit}>{fruit}</li>
    ))}
  </ul>
);
```

[Voir l'exemple sur PlayCode](https://playcode.io/1940876)

Et l√† : **BAM** ! üí•  
Tu viens de cr√©er une liste de fruits en utilisant un tableau de fruits.

Mais par contre...

{% callout type="question" title="C'est quoi ce `key` qui vient d'appara√Ætre ?" %}

La `key` est une propri√©t√© sp√©ciale que React utilise pour identifier chaque √©l√©ment de mani√®re unique.  
Cela permet √† React de savoir quel √©l√©ment a √©t√© ajout√©, modifi√© ou supprim√©.

Il est **obligatoire** d'avoir une `key` **unique** pour chaque √©l√©ment d'une liste.  
Si tu listes des √©l√©ments qui ont un identifiant unique _(comme l'`id` qu'on aura dans nos donn√©es stock√©es dans une base de donn√©es par exemple)_, tu peux utiliser cet identifiant comme `key`.

{% /callout %}

## üì¶ Les props

Les **props** _(ou propri√©t√©s)_ sont des arguments que l'on peut passer √† un composant React.  
Je ne vais pas trop rentrer dans les d√©tails ici, car on va les voir dans l'article d'apr√®s !

Mais pour te donner un aper√ßu, voici comment on peut passer des **props** √† un composant :

{% tabs defaultSelectedTab="jsx" %}

{% tab value="jsx" label="JSX" %}

```jsx
const Button = (props) => {
  return <button onClick={props.onClick}>{props.children}</button>;
};
```

{% /tab %}

{% tab value="tsx" label="TSX" %}

```tsx
type ButtonProps = {
  onClick: () => void;
  children: React.ReactNode;
};

const Button = (props: ButtonProps) => {
  return <button onClick={props.onClick}>{props.children}</button>;
};
```

{% /tab %}

{% /tabs %}

Ici, on a un composant `Button` qui prend deux **props** : `onClick` et `children`.  
`onClick` est une fonction qui sera appel√©e lorsqu'on cliquera sur le bouton, et `children` est tout ce qui se trouve entre les balises ouvrante et fermante du composant.

## Conclusion

Alors, plut√¥t cool le **JSX** non ? üòé

M√™me si cette syntaxe rebute certains d√©veloppeurs _(souvent ils se la jouent puristes, mais chuuuuut ü§´)_, elle est toutefois tr√®s appr√©ci√©e pour sa simplicit√© et sa lisibilit√©.  
Question de go√ªt apr√®s tout !
